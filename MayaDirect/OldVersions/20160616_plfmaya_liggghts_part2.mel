global proc plfmaya_liggghts_part2()
{



//Begin by defining framerate etc

float $frame_rate = 250;
float $timestep = 0.000001;  //check this is the same is in output below
float $timesteps_per_frame = (1/$frame_rate)/$timestep;

$fileId2 = `fopen "run.liggghts" "w"`;

fprint $fileId2 ("#This LIGGGHTS input file was autoGenerated using Maya->Liggghts script by Peter Falkingham\n\n");

fprint $fileId2 ("#----------SET UP FOLDER FOR OUTPUT----------#\n\n");
fprint $fileId2 ("shell mkdir post\n\n");

fprint $fileId2 ("#processors 1 1 1\n\n");

fprint $fileId2 ("#----------SYSTEM VARIABLES----------#\n\n");
fprint $fileId2 ("#These are variables used later that get frequently altered\n");
fprint $fileId2 ("variable	r equal 0.001		# RADIUS of the particles (metres)\n");
fprint $fileId2 ("variable	E equal 5.0e7		# Young's modulus of particles (MPa)\n");
fprint $fileId2 ("variable	f equal 0.8		    # Coefficient of Friction (?)\n");
fprint $fileId2 ("variable	c equal 75000		# Cohesion energy density (?)\n");
fprint $fileId2 ("variable	d equal 1200		# Density of particles (Kg/m3)\n");
fprint $fileId2 ("variable	v equal 0.4		    # Poisson ratio\n");
fprint $fileId2 ("variable	s equal 0.000001		# time step size (seconds)\n");
fprint $fileId2 ("variable	e equal 4000		# dump every\n\n");

fprint $fileId2 ("#----------SIMULATION SETTINGS----------#\n");
fprint $fileId2 ("# These are required for the simulation\n");
fprint $fileId2 ("units 		si				# units are set to SI\n");
fprint $fileId2 ("atom_style 	granular		# standard for DEM - NOTE THAT SPHERE ALSO WORKS\n");
fprint $fileId2 ("boundary	    f f f			    # Boundary s = non-periodic, shrinkwrapped\n");
fprint $fileId2 ("newton 		off				# Turns newtons 3rd law on/off: on = slight computational savings, but 2x more communication\n");
fprint $fileId2 ("communicate	single vel yes	# standard processor communication settings\n");
fprint $fileId2 ("neighbor	    $r bin			    #nearest neighbor course contact detection\n");
fprint $fileId2 ("neigh_modify	every 1 delay 0 check yes	#rebuild list every step, if checked.\n\n");

fprint $fileId2 ("#----------READ THE RESTART FILE----------#\n");
fprint $fileId2 ("read_restart restart.res			# Reads the restart file\n\n");

fprint $fileId2 ("#----------MATERIAL PROPERTIES----------#\n");
fprint $fileId2 ("# These determine the behaviour of the simulation\n");
fprint $fileId2 ("fix	m1 all property/global youngsModulus peratomtype $E\n");
fprint $fileId2 ("fix	m2 all property/global poissonsRatio peratomtype $v\n");
fprint $fileId2 ("fix	m3 all property/global coefficientRestitution peratomtypepair 1 0.9\n");
fprint $fileId2 ("fix 	m4 all property/global coefficientFriction peratomtypepair 1 $f\n");
fprint $fileId2 ("fix 	m5 all property/global characteristicVelocity scalar 1.0\n");
fprint $fileId2 ("fix 	m6 all property/global cohesionEnergyDensity peratomtypepair 1 $c\n\n");

fprint $fileId2 ("#----------FORCE MODEL----------#\n");
fprint $fileId2 ("# Takes the given material properties and applies them to all particles\n");
fprint $fileId2 ("pair_style	gran model hertz tangential history cohesion sjkr #:pre # hertzian with cohesion\n");
fprint $fileId2 ("pair_coeff	* * 			# applies this interaction to all particle pairs\n\n");

fprint $fileId2 ("#----------ADDITIONAL SETTINGS----------#\n");
fprint $fileId2 ("fix 		nsph all nve/sphere			# Initialises time integration\n");
fprint $fileId2 ("fix       gravi all gravity 9.81 vector 0.0 0.0 -1.0	#Gravity\n\n");
fprint $fileId2 ("timestep	$s\n\n");

//Previously had here cutting the atoms, but will move this to setup script

fprint $fileId2 ("#--------INITIALIZATION OF MESHES-----#\n");
fprint $fileId2 ("fix    tray all mesh/surface file simtray.stl type 1\n");  

//Get first animation frame translation + rotation
float $anStart = `playbackOptions -q -minTime`;
currentTime $anStart;
////For loop for each bone

string $bones[] = `ls -sl`;
string $item;

for ($item in $bones)
{

    string $buffer[];
    tokenize $item ":" $buffer;
    string $cleanName = $buffer[size($buffer)-1];

    fprint $fileId2 ("fix    "+$cleanName+" all mesh/surface file "+$cleanName+".stl type 1\n"); //rotate axis "+$ax+" "+$ay+" "+$az+" angle "+$ang+" move "+$tx+" "+$ty+" "+$tz+"\n");
}

fprint $fileId2 ("fix cont1 all wall/gran model hertz tangential history mesh n_meshes "+(size($bones)+1)+" meshes tray");
for ($item in $bones)
{
    string $buffer[];
    tokenize $item ":" $buffer;
    string $cleanName = $buffer[size($buffer)-1];
    fprint $fileId2 (" "+$cleanName+" ");
}
fprint $fileId2 ("\n\n");

fprint $fileId2 ("#--------COMPUTATION----------#\n");
fprint $fileId2 ("# sets up what will be computed\n");
fprint $fileId2 ("compute	rke all erotate/sphere\n");
fprint $fileId2 ("compute 	mudisp all displace/atom\n");
fprint $fileId2 ("compute	fc all wall/gran/local id pos force\n\n");

fprint $fileId2 ("#----------DUMP FILES----------#\n");
fprint $fileId2 ("dump		dmp all custom $e post/dump*.bin id x y z vx vy vz fx fy fz radius\n");
fprint $fileId2 ("dump 	    dumpstl1 all mesh/vtk $e post/footcomp2_*.vtk id");
for ($item in $bones)
{
    string $buffer[];
    tokenize $item ":" $buffer;
    string $cleanName = $buffer[size($buffer)-1];
    fprint $fileId2 (" "+$cleanName+" ");

}
fprint $fileId2 ("\n");
fprint $fileId2 ("#dump 	    dumpstl2 all mesh/vtk $e post/tray_*.vtk id tray");
fprint $fileId2 ("\n");
fprint $fileId2 ("#dump 		forcedump all local $e post/dump*.forcedata  c_fc[1] c_fc[2] c_fc[3] c_fc[4] c_fc[5] c_fc[6] c_fc[7] c_fc[8] c_fc[9] c_fc[10] c_fc[11] c_fc[12]\n\n");

fprint $fileId2 ("run 4000 #Lets particles settle before motion\n\n");

//turn off outputting tray after a single output file.
fprint $fileId2 ("#undump dumpstl2\n\n");

fprint $fileId2 ("###############################################################\n");
fprint $fileId2 ("##motion\n");
fprint $fileId2 ("###############################################################\n\n");


//cycle through timesteps (frames), calculate translation and rotation required, 

    //Declare some variables for within the loops
    float $currX;
    float $currY;
    float $currZ;
    float $currRX;
    float $currRY;
    float $currRZ;
    float $prevX;
    float $prevY;
    float $prevZ;
    float $prevRX;
    float $prevRY;
    float $prevRZ;


float $anEnd = `playbackOptions -q -maxTime`;
int $i = ($anStart+1);

for ($i;$i<=$anEnd;++$i)
{
    for ($item in $bones)
    {
    string $buffer[];
    tokenize $item ":" $buffer;
    string $cleanName = $buffer[size($buffer)-1];

        //Get current x, y, z, rotation + translation
        currentTime $i;
        $currX = getAttr ($item+".translateX");
        $currY = getAttr ($item+".translateY");
        $currZ = getAttr ($item+".translateZ");
        $currRX = getAttr ($item+".rotateX");
        $currRY = getAttr ($item+".rotateY");
        $currRZ = getAttr ($item+".rotateZ");
        
        
        //Get previous xyz rot + trans
        currentTime ($i-1);
        $prevX = `getAttr ($item+".translateX")`;
        $prevY = `getAttr ($item+".translateY")`;
        $prevZ = `getAttr ($item+".translateZ")`;
        $prevRX = `getAttr  ($item+".rotateX")`;
        $prevRY = `getAttr ($item+".rotateY")`;
        $prevRZ = `getAttr ($item+".rotateZ")`;

        
        //Command Translation
        fprint $fileId2 ("fix    move"+$cleanName+$i+" all move/mesh mesh "+$cleanName+" linear "+($currX-$prevX)*$frame_rate+" "+($currY-$prevY)*$frame_rate+" "+($currZ-$prevZ)*$frame_rate+"\n");
        
        //calculate rotation since last frame:
        float $diffRX = $currRX - $prevRX;
        float $diffRY = $currRY - $prevRY;
        float $diffRZ = $currRZ - $prevRZ;
        
        //New rotation calculation based on matrix from xform -q -m <mesh>

        float $deargodno[] = `xform -q -m $item`;     
        
  
      
        //Calculate y as cross product of x and z (z being 0 0 1) - based on http://www.mathsisfun.com/algebra/vectors-cross-product.html
        float $cx = ($deargodno[2]*0) - ($deargodno[1]*1);
        float $cy = ($deargodno[0]*1) - ($deargodno[2]*0);
        float $cz = ($deargodno[1]*0) - ($deargodno[0]*0);
 
        //do x   
        if ($diffRX != 0)
        {
            float $periodX = (360/$diffRX) * (1/$frame_rate);
            fprint $fileId2 ("fix    rotatex"+$cleanName +$i+" all move/mesh mesh "+$cleanName+" rotate origin "+$prevX+" "+$prevY+" "+$prevZ+" axis "+$deargodno[0]+" "+$deargodno[1]+" "+$deargodno[2]+" period "+$periodX+"\n");      
        }
        //do y
        if ($diffRY != 0)
        {
            float $periodY = (360/$diffRY) * (1/$frame_rate);
            fprint $fileId2 ("fix    rotatey"+$cleanName+$i+" all move/mesh mesh "+$cleanName+" rotate origin "+$prevX+" "+$prevY+" "+$prevZ+" axis "+$cx+" "+$cy+" "+$cz+" period "+$periodY+"\n");        
        }
                //do Z
        if ($diffRZ != 0)
        {
            float $periodZ = (360/$diffRZ) * (1/$frame_rate);
		 fprint $fileId2 ("fix    rotatez"+$cleanName+$i+" all move/mesh mesh "+$cleanName+" rotate origin "+$prevX+" "+$prevY+" "+$prevZ+" axis 0 0 1 period "+$periodZ+"\n");
        }         
    }
    fprint $fileId2 ("run "+$timesteps_per_frame+"\n");
    for ($item in $bones)
    {

    string $buffer[];
    tokenize $item ":" $buffer;
    string $cleanName = $buffer[size($buffer)-1];

        //have to check ang again as not storing it!
        currentTime $i;
        $currRX = getAttr ($item+".rotateX");
        $currRY = getAttr ($item+".rotateY");
        $currRZ = getAttr ($item+".rotateZ");
              
        //Get previous xyz rot + trans
        currentTime ($i-1);
        $prevRX = `getAttr ($item+".rotateX")`;
        $prevRY = `getAttr ($item+".rotateY")`;
        $prevRZ = `getAttr ($item+".rotateZ")`;
        
        //calculate rotation since last frame:
        float $diffRX = $currRX - $prevRX;
        float $diffRY = $currRY - $prevRY;
        float $diffRZ = $currRZ - $prevRZ;
        

        //do y
        if ($diffRY != 0)
        {
            fprint $fileId2 ("unfix rotatey"+$cleanName+$i+"\n");
        }  
                        //do x
        if ($diffRX != 0)
        {
            fprint $fileId2 ("unfix rotatex"+$cleanName+$i+"\n");
        }    
        //do z   
        if ($diffRZ != 0)
        {
            fprint $fileId2 ("unfix rotatez"+$cleanName+$i+"\n");
        }      

        fprint $fileId2 ("unfix move"+$cleanName+$i+"\n");
    }
}






fclose $fileId2;
}